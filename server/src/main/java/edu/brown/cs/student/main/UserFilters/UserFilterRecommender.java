package edu.brown.cs.student.main.UserFilters;

import edu.brown.cs.student.main.BloomFilter.SimilarityMetrics.SimilarXNOR;
import edu.brown.cs.student.main.BloomFilter.SimilarityMetrics.SimilarityMetric;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * The BloomFilterRecommender stores functionality for getting a list of neighbors and returning
 * the IDs of those neighbors in a string format. This is used for the similar_bf command
 * when generating a list of k nearest neighbors to a student with given id.
 *
 */
public class UserFilterRecommender {
  private final int numNeighbors;
  private final String id;
  private final UserFiltersMap userMap;
  private final UserFilterComparator userComparator;
  private SimilarityMetric[] defaultSimilarityMetric =  {new SimilarXNOR(), new SimilarXNOR(), new SimilarXNOR()};
  private double[] defaultWeights = {1, 1, 1};
  /**
   * The BloomFilterRecommender constructor takes in a number of neighbors, id, BloomFilterList,
   * and similarity metric.
   * @param numNeighbors integer, representing number of neighbors to find
   * @param id integer, representing ID of student we are finding neighbors for
   * @param userMap represents database of filters for students
   * @throws IllegalArgumentException numNeighbors is negative or student cannot be found via ID
   */
  public UserFilterRecommender(int numNeighbors, String id, UserFiltersMap userMap,
                                SimilarityMetric[] metrics, double[] weights) throws IllegalArgumentException {
    if (numNeighbors < 0) {
      throw new IllegalArgumentException("number of neighbors to find should be non-negative"
          + "integer");
    }
    this.numNeighbors = numNeighbors;
    this.userMap = userMap;
    this.id = id;
    if (!userMap.containsKey(id)) {
      throw new IllegalArgumentException("ID is invalid, could not find student "
          + "with given ID in database");
    }

    // If a similarity metric is provided, change the default metric for comparator
    if (metrics != null) {
      this.setDefaultMetrics(metrics);
    }
    // If weights are provided, change default weights for comparator
    if (weights != null) {
      this.setDefaultWeights(weights);
    }
    this.userComparator = new UserFilterComparator(userMap.get(id), this.defaultSimilarityMetric, this.defaultWeights);
  }
  /**
   * Gets nearest k neighbors to student with given ID.
   * @return List of IDs representing the nearest neighbors.
   */
  public List<String> getNeighborIDs() {
    Map<String, UserFilters> copy = userMap.copyMap();
    copy.remove(id);
    List<Map.Entry<String, UserFilters>> entries = new ArrayList<>(copy.entrySet());
    Collections.shuffle(entries);
    entries.sort((e1, e2) -> userComparator.compare(e1.getValue(), e2.getValue()));
    return entries.stream().map(Map.Entry::getKey).limit(numNeighbors).collect(Collectors.toList());
  }
  /**
   * Uses list of Pairs generated by getNeighbors() to create a string of IDs that can be returned
   * and printed by REPL.
   *
   * @return String containing IDs for each of the neighbors/similar students
   *
   */
  @Deprecated
  public String nearestNeighborsString() {
    return String.join("\n", getNeighborIDs());
  }

  /**
   * Private method to change default metric if a metric argument is passed to constructor.
   * @param metrics Similarity Metric, defines similarity between two bloom filters
   */
  private void setDefaultMetrics(SimilarityMetric[] metrics) {
    this.defaultSimilarityMetric = metrics;
  }
  private void setDefaultWeights(double[] weights) {
    this.defaultWeights = weights;
  }
}
